ðŸ“˜ DAY 4 â€” Stack, Heap, and Function Address Logging
ðŸŽ¯ Goal

Understand how the stack, heap, and code segment appear in memory at runtime â€” and verify their behavior using a small C program.

Today you learn:

Why stack grows downward

Why heap grows upward

Why function addresses (text segment) stay fixed unless PIE

How ASLR affects stack + heap

How to record these addresses for research



ðŸ§  THEORY
ðŸ”¹ 1. Stack

The stack is a LIFO memory region used for:

local variables

function call frames

return addresses

Memory layout:

High addresses
     â†“ (stack grows downward)
Low addresses


Meaning:

Every new local variable â†’ lower memory address

Function calls push new frames downward

Stack is close to kernel memory, so ASLR randomizes the base each run

-----------


ðŸ”¹ 2. Heap

The heap is used for dynamic allocations (malloc, calloc, realloc).

Memory layout:
```
Low addresses
     â†‘ (heap grows upward)
High addresses
```

Meaning:

Every malloc() tends to allocate higher addresses

ASLR randomizes the heap base as well


---------

ðŸ”¹ 3. Code Segment (Text Segment)

Contains:

machine instructions

function entry points (main, other functions)

Properties:

usually read + execute (RX)

does not change across allocations

stays fixed unless PIE is enabled

If PIE is enabled, the entire binary is position-independent, so function addresses will also move.



---------

ðŸ”¹ 4. Why These Addresses Matter

This is core binary exploitation foundation:

Stack addresses â†’ for stack-based buffer overflows

Heap addresses â†’ for heap exploitation, UAF, tcache attacks

Function addresses â†’ for ROP, GOT overwrite, ret2text, ASLR bypass

Knowing how to observe them is mandatory to understand how a process lives in memory.
