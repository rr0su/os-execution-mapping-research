# Week 1 — Day 2 Log

## Goal
Document the full compiler pipeline (preprocess → compile → assemble → link).

## Files analyzed
- code/hello.c
- experiments/hello.i
- experiments/hello.s
- experiments/hello.o
- experiments/hello.bin

## Notes
This experiment shows how a simple C program becomes assembly, then an object file, then a final binary.

## Commands Used\n
```bash
# preprocess → hello.i
gcc -E code/hello.c -o experiments/hello.i

# compile to assembly → hello.s
gcc -S code/hello.c -o experiments/hello.s

# assemble → hello.o
gcc -c code/hello.c -o experiments/hello.o

# link → hello.bin
gcc experiments/hello.o -o experiments/hello.bin
```
## File Explanations

### hello.i — Preprocessed C
All #include expanded, macros inserted, pure C code.

### hello.s — Assembly Output
Human-readable assembly generated by the compiler.

### hello.o — Object File
Machine code + relocation info, not yet linked.

### hello.bin — Final Executable
ELF binary ready to run on Linux.

## Disassembly Snippet

A small part of the binary's assembly:

```asm

experiments/hello.bin:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:	f3 0f 1e fa          	endbr64
    1004:	48 83 ec 08          	sub    $0x8,%rsp
    1008:	48 8b 05 d9 2f 00 00 	mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
    100f:	48 85 c0             	test   %rax,%rax
    1012:	74 02                	je     1016 <_init+0x16>
    1014:	ff d0                	call   *%rax
    1016:	48 83 c4 08          	add    $0x8,%rsp
    101a:	c3                   	ret

Disassembly of section .plt:

0000000000001020 <.plt>:
    1020:	ff 35 9a 2f 00 00    	push   0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>
```
## Diagram To Add Later
- Flow: hello.c → hello.i → hello.s → hello.o → hello.bin
- Visual of compilation stages

